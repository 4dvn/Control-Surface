/**
 * This examples shows how to use a button matrix to read many switches.
 * 
 * @boards  AVR, AVR USB, Due, Nano 33, Teensy 3.x, ESP32
 * 
 * Connections
 * -----------
 * 
 * Connect a 4 Ã— 3 matrix of buttons with the rows to pins 2, 3, 4 and 5, 
 * and the columns to pins 6, 7 and 8.
 * 
 * Pull-up resistors are not necessary, because the internal ones will be used. 
 * 
 * If you want to be able to press multiple buttons at once, add a diode 
 * in series with each button:  
 * @image html Button-matrix.png
 * 
 * Behavior
 * --------
 * 
 * When you press one of the buttons, a note on event for the corresponding note
 * is sent, when you release it, a note off event is sent.
 * 
 * Mapping
 * -------
 *
 * The note numbers are specified in the `addresses` array.
 * Map accordingly in your DAW or DJ software.
 *
 * Written by Pieter P, 24/09/2017  
 * https://github.com/tttapa/Control-Surface
 */

#include <Control_Surface.h>

USBMIDI_Interface midi;
// Fours potentiometer to analog pinout

CCPotentiometer potentiometer(A0, {MIDI_CC::Channel_Volume, CHANNEL_2});

CCPotentiometer potentiometer(A1, {MIDI_CC::Channel_Volume, CHANNEL_3});

CCPotentiometer potentiometer(A2, {MIDI_CC::Channel_Volume, CHANNEL_4});

CCPotentiometer potentiometer(A3, {MIDI_CC::Channel_Volume, CHANNEL_5});

// The note numbers corresponding to the buttons in the matrix
const AddressMatrix<4, 4> addresses = {{
  {48, 49, 50, 51},// Ableton drumrack map
  {44, 45, 46, 47},
  {40, 41, 42, 43},
  {36, 37, 38, 39},
}};

NoteButtonMatrix<4, 4> buttonmatrix = {
  {2, 3, 4, 5}, // row pins
  {6, 7, 8, 9},    // column pins
  addresses,    // address matrix
  CHANNEL_1,    // channel and cable number
};

void setup() {
  Control_Surface.begin();
}

void loop() {
  Control_Surface.loop();
}
